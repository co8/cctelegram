/**
 * Global Teardown for CCTelegram Bridge Testing
 * Cleans up test environment and generates final reports
 */

import { FullConfig } from '@playwright/test';
import path from 'path';
import fs from 'fs/promises';
import { DebugLogger } from '../utils/debug-logger';

async function globalTeardown(config: FullConfig) {
  const logger = new DebugLogger('global-teardown', true);
  logger.info('Starting global test teardown...');

  try {
    // Generate test summary report
    await generateTestSummary(logger);
    
    // Clean up test processes
    await cleanupTestProcesses(logger);
    
    // Archive test artifacts
    await archiveTestArtifacts(logger);
    
    // Clean up temporary files
    await cleanupTempFiles(logger);
    
    logger.info('✅ Global teardown completed successfully');

  } catch (error) {
    logger.error('❌ Global teardown failed:', error);
    // Don't throw here - we want teardown to complete even if some steps fail
  }
}

async function generateTestSummary(logger: DebugLogger): Promise<void> {
  logger.info('Generating test summary report...');

  try {
    const reportPath = path.resolve('test-results/test-summary.md');
    const timestamp = new Date().toISOString();
    
    // Check for test results
    const resultsPath = path.resolve('test-results/results.json');
    let testResults = null;
    
    try {
      const resultsContent = await fs.readFile(resultsPath, 'utf-8');
      testResults = JSON.parse(resultsContent);
    } catch {
      logger.debug('No test results file found');
    }

    // Generate summary
    const summary = [
      '# CCTelegram Bridge Test Summary',
      '',
      `**Generated:** ${timestamp}`,
      '',
      '## Test Overview',
      '',
      testResults ? `- **Total Tests:** ${testResults.suites?.length || 0}` : '- **Total Tests:** Unknown',
      testResults ? `- **Passed:** ${countTests(testResults, 'passed')}` : '- **Passed:** Unknown', 
      testResults ? `- **Failed:** ${countTests(testResults, 'failed')}` : '- **Failed:** Unknown',
      testResults ? `- **Skipped:** ${countTests(testResults, 'skipped')}` : '- **Skipped:** Unknown',
      '',
      '## Debug Focus: /tasks Command Issue',
      '',
      '### Issue Description',
      'Users are seeing old static data (28/29 tasks, 96.55%) instead of live TaskMaster data in the /tasks command response.',
      '',
      '### Test Results',
      // Additional analysis would go here based on test results
      'See detailed test results in the HTML report.',
      '',
      '## Artifacts Generated',
      '',
      '- **HTML Report:** `test-results/report/index.html`',
      '- **Debug Logs:** `test-results/logs/`',
      '- **Screenshots:** `test-results/screenshots/`',
      '- **Videos:** `test-results/videos/`',
      '- **Traces:** `test-results/traces/`',
      '',
      '## Next Steps',
      '',
      '1. Review the HTML report for detailed test execution',
      '2. Check debug logs for bridge and MCP interaction details',
      '3. Examine screenshots/videos for visual confirmation of issues',
      '4. Based on test results, implement fixes and re-run tests',
      '',
      '---',
      '*Generated by CCTelegram Bridge Debug Test Suite*'
    ].join('\n');

    await fs.writeFile(reportPath, summary);
    logger.info(`✓ Test summary generated: ${reportPath}`);

  } catch (error) {
    logger.warn('Failed to generate test summary:', error);
  }
}

function countTests(results: any, status: string): number {
  if (!results.suites) return 0;
  
  let count = 0;
  
  function countInSuite(suite: any) {
    if (suite.tests) {
      suite.tests.forEach((test: any) => {
        if (test.results && test.results.some((r: any) => r.status === status)) {
          count++;
        }
      });
    }
    
    if (suite.suites) {
      suite.suites.forEach(countInSuite);
    }
  }
  
  results.suites.forEach(countInSuite);
  return count;
}

async function cleanupTestProcesses(logger: DebugLogger): Promise<void> {
  logger.info('Cleaning up test processes...');

  // Kill any remaining test processes
  const processesToKill = [
    'cc-telegram-bridge',
    'node.*mcp-server',
    'node.*telegram-mock'
  ];

  for (const processPattern of processesToKill) {
    try {
      const { exec } = require('child_process');
      await new Promise((resolve) => {
        exec(`pkill -f "${processPattern}"`, (error) => {
          if (error) {
            logger.debug(`No processes found matching: ${processPattern}`);
          } else {
            logger.info(`✓ Killed processes matching: ${processPattern}`);
          }
          resolve(undefined);
        });
      });
    } catch (error) {
      logger.debug(`Failed to kill processes matching ${processPattern}:`, error);
    }
  }

  logger.info('✓ Test processes cleaned up');
}

async function archiveTestArtifacts(logger: DebugLogger): Promise<void> {
  logger.info('Archiving test artifacts...');

  try {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const archiveDir = path.resolve('test-results', `archive-${timestamp}`);
    
    await fs.mkdir(archiveDir, { recursive: true });
    
    // Copy important artifacts
    const artifactsToArchive = [
      'logs',
      'screenshots',
      'videos',
      'traces',
      'report',
      'results.json',
      'test-summary.md'
    ];
    
    for (const artifact of artifactsToArchive) {
      const sourcePath = path.resolve('test-results', artifact);
      const destPath = path.join(archiveDir, artifact);
      
      try {
        const stat = await fs.stat(sourcePath);
        
        if (stat.isDirectory()) {
          await copyDirectory(sourcePath, destPath);
        } else {
          await fs.copyFile(sourcePath, destPath);
        }
        
        logger.debug(`✓ Archived: ${artifact}`);
      } catch (error) {
        logger.debug(`Could not archive ${artifact}:`, error.message);
      }
    }
    
    logger.info(`✓ Artifacts archived to: ${archiveDir}`);

  } catch (error) {
    logger.warn('Failed to archive test artifacts:', error);
  }
}

async function copyDirectory(source: string, dest: string): Promise<void> {
  await fs.mkdir(dest, { recursive: true });
  
  const entries = await fs.readdir(source, { withFileTypes: true });
  
  for (const entry of entries) {
    const sourcePath = path.join(source, entry.name);
    const destPath = path.join(dest, entry.name);
    
    if (entry.isDirectory()) {
      await copyDirectory(sourcePath, destPath);
    } else {
      await fs.copyFile(sourcePath, destPath);
    }
  }
}

async function cleanupTempFiles(logger: DebugLogger): Promise<void> {
  logger.info('Cleaning up temporary files...');

  const tempDirs = [
    '/tmp/test-events',
    '/tmp/test-responses'
  ];

  for (const tempDir of tempDirs) {
    try {
      const files = await fs.readdir(tempDir).catch(() => []);
      
      for (const file of files) {
        await fs.unlink(path.join(tempDir, file));
      }
      
      await fs.rmdir(tempDir).catch(() => {});
      logger.debug(`✓ Cleaned temp directory: ${tempDir}`);
      
    } catch (error) {
      logger.debug(`Could not clean temp directory ${tempDir}:`, error.message);
    }
  }

  logger.info('✓ Temporary files cleaned up');
}

export default globalTeardown;