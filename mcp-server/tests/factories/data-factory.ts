/**
 * Data Factory for Test Data Generation
 * Provides functions to generate test data with customizable properties
 */

import { randomUUID } from 'crypto';
import { CCTelegramEvent, TelegramResponse, EventType, BridgeStatus } from '../../src/types.js';

/**
 * Factory options for event generation
 */
export interface EventFactoryOptions {
  type?: EventType;
  title?: string;
  description?: string;
  task_id?: string;
  source?: string;
  timestamp?: string;
  data?: any;
}

/**
 * Factory options for response generation
 */
export interface ResponseFactoryOptions {
  id?: string;
  user_id?: number;
  message?: string;
  timestamp?: string;
  event_id?: string;
  action?: string;
  data?: any;
}

/**
 * Factory options for bridge status generation
 */
export interface BridgeStatusFactoryOptions {
  success?: boolean;
  status?: string;
  uptime?: number;
  version?: string;
  last_activity?: string | null;
  error?: string;
  health_check?: {
    telegram_connection?: boolean;
    file_system_access?: boolean;
    memory_usage?: number;
    cpu_usage?: number;
  };
  warnings?: string[];
  errors?: string[];
}

/**
 * Generate a valid CCTelegramEvent with optional overrides
 */
export function createEvent(options: EventFactoryOptions = {}): CCTelegramEvent {
  const now = new Date().toISOString();
  
  return {
    type: options.type ?? 'info_notification',
    title: options.title ?? 'Test Event',
    description: options.description ?? 'This is a test event generated by the data factory',
    task_id: options.task_id,
    source: options.source ?? 'claude-code',
    timestamp: options.timestamp ?? now,
    data: options.data
  };
}

/**
 * Generate a valid TelegramResponse with optional overrides
 */
export function createResponse(options: ResponseFactoryOptions = {}): TelegramResponse {
  const now = new Date().toISOString();
  
  return {
    id: options.id ?? `response-${randomUUID()}`,
    user_id: options.user_id ?? Math.floor(Math.random() * 1000000000),
    message: options.message ?? 'Test response message',
    timestamp: options.timestamp ?? now,
    event_id: options.event_id,
    action: options.action,
    data: options.data
  };
}

/**
 * Generate a valid BridgeStatus with optional overrides
 */
export function createBridgeStatus(options: BridgeStatusFactoryOptions = {}): BridgeStatus {
  const now = new Date().toISOString();
  
  return {
    success: options.success ?? true,
    status: options.status ?? 'running',
    uptime: options.uptime ?? 3600,
    version: options.version ?? '0.6.0',
    last_activity: options.last_activity ?? now,
    error: options.error,
    health_check: options.health_check ? {
      telegram_connection: options.health_check.telegram_connection ?? true,
      file_system_access: options.health_check.file_system_access ?? true,
      memory_usage: options.health_check.memory_usage ?? 45.2,
      cpu_usage: options.health_check.cpu_usage ?? 12.8
    } : undefined,
    warnings: options.warnings,
    errors: options.errors
  };
}

/**
 * Generate multiple events with sequential properties
 */
export function createEventBatch(count: number, baseOptions: EventFactoryOptions = {}): CCTelegramEvent[] {
  return Array.from({ length: count }, (_, index) => {
    const timestamp = new Date(Date.now() + index * 1000).toISOString();
    return createEvent({
      ...baseOptions,
      title: `${baseOptions.title ?? 'Test Event'} ${index + 1}`,
      timestamp,
      task_id: baseOptions.task_id ? `${baseOptions.task_id}-${index + 1}` : undefined
    });
  });
}

/**
 * Generate multiple responses with sequential properties
 */
export function createResponseBatch(count: number, baseOptions: ResponseFactoryOptions = {}): TelegramResponse[] {
  return Array.from({ length: count }, (_, index) => {
    const timestamp = new Date(Date.now() + index * 1000).toISOString();
    const actions = ['approve', 'deny', 'defer'];
    
    return createResponse({
      ...baseOptions,
      id: `${baseOptions.id ?? 'response'}-${index + 1}`,
      message: `${baseOptions.message ?? 'Response'} ${index + 1}`,
      timestamp,
      action: baseOptions.action ?? actions[index % actions.length],
      user_id: (baseOptions.user_id ?? 123456789) + index
    });
  });
}

/**
 * Generate event with specific validation failure
 */
export function createInvalidEvent(validationType: string): Partial<CCTelegramEvent> {
  const baseEvent = createEvent();
  
  switch (validationType) {
    case 'missing_title':
      const { title, ...withoutTitle } = baseEvent;
      return withoutTitle;
      
    case 'missing_description':
      const { description, ...withoutDescription } = baseEvent;
      return withoutDescription;
      
    case 'invalid_type':
      return { ...baseEvent, type: 'invalid_event_type' as any };
      
    case 'title_too_long':
      return { ...baseEvent, title: 'x'.repeat(201) };
      
    case 'description_too_long':
      return { ...baseEvent, description: 'x'.repeat(2001) };
      
    case 'invalid_task_id':
      return { ...baseEvent, task_id: 'not-a-valid-uuid' };
      
    case 'invalid_source':
      return { ...baseEvent, source: 'invalid source with @symbols' };
      
    default:
      return baseEvent;
  }
}

/**
 * Generate response with specific validation failure
 */
export function createInvalidResponse(validationType: string): Partial<TelegramResponse> {
  const baseResponse = createResponse();
  
  switch (validationType) {
    case 'missing_id':
      const { id, ...withoutId } = baseResponse;
      return withoutId;
      
    case 'missing_user_id':
      const { user_id, ...withoutUserId } = baseResponse;
      return withoutUserId;
      
    case 'missing_message':
      const { message, ...withoutMessage } = baseResponse;
      return withoutMessage;
      
    case 'missing_timestamp':
      const { timestamp, ...withoutTimestamp } = baseResponse;
      return withoutTimestamp;
      
    case 'invalid_timestamp':
      return { ...baseResponse, timestamp: 'not-a-valid-date' };
      
    case 'invalid_user_id':
      return { ...baseResponse, user_id: 'not-a-number' as any };
      
    default:
      return baseResponse;
  }
}

/**
 * Generate responses with specific time ranges for age testing
 */
export function createTimeBasedResponses() {
  const now = Date.now();
  const minute = 60 * 1000;
  const hour = 60 * minute;
  const day = 24 * hour;
  
  return {
    veryRecent: createResponse({
      id: 'response-very-recent',
      message: 'Very recent response',
      timestamp: new Date(now - 5 * minute).toISOString()
    }),
    recent: createResponse({
      id: 'response-recent',
      message: 'Recent response',
      timestamp: new Date(now - 30 * minute).toISOString()
    }),
    old: createResponse({
      id: 'response-old',
      message: 'Old response',
      timestamp: new Date(now - day).toISOString()
    }),
    veryOld: createResponse({
      id: 'response-very-old',
      message: 'Very old response',
      timestamp: new Date(now - 4 * day).toISOString()
    })
  };
}

/**
 * Generate task status data for testing
 */
export function createTaskStatusData() {
  return {
    taskmaster_available: true,
    taskmaster_tasks: [
      {
        id: '1',
        title: 'Implement Authentication System',
        status: 'in-progress',
        priority: 'high',
        dependencies: [],
        subtasks: [
          {
            id: '1.1',
            title: 'Set up JWT middleware',
            status: 'done',
            priority: 'high'
          },
          {
            id: '1.2',
            title: 'Implement password hashing',
            status: 'in-progress',
            priority: 'high'
          }
        ]
      },
      {
        id: '2',
        title: 'Add Input Validation',
        status: 'pending',
        priority: 'medium',
        dependencies: ['1']
      }
    ],
    claude_code_tasks: [
      {
        id: 'cc-1',
        description: 'Fix TypeScript compilation errors',
        status: 'completed'
      },
      {
        id: 'cc-2',
        description: 'Update documentation',
        status: 'pending'
      }
    ]
  };
}

/**
 * Generate file system mock data
 */
export function createFileSystemMocks() {
  return {
    eventFiles: [
      'event-001.json',
      'event-002.json',
      'event-003.json'
    ],
    responseFiles: [
      'response-001.json',
      'response-002.json',
      'response-003.json'
    ],
    eventData: createEventBatch(3),
    responseData: createResponseBatch(3)
  };
}